local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"

local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

Library.ForceCheckbox = false
Library.ShowToggleFrameInKeybinds = true

Library:Notify('Loaded Konan.cc')

local Window = Library:CreateWindow({
    Title = 'Konan.lua BuyersðŸŒŸ',
    TitleAlign = Enum.TextXAlignment.Center,
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.1
})

local Tabs = {
    Main = Window:AddTab('Main'),
    Misc = Window:AddTab('Misc'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Legit')



getgenv().Francium = {
    Enabled = true,
    HorizontalPrediction = 0.1,
    VerticalPrediction = 0.1,
    jumpoffset = -1,
    ResolverEnabled = false,
    SelectedPart = "HumanoidRootPart",
    AutoPrediction = true,
    AutoPredMode = "PingBased",  
    Macro = "OFF", -- OFF or ON
    ShootDelay = 0.22,
    NoGroundShot = true,
    AutoAir = false,
    LookAt = true,
    smoothness = 0.900,
    TracerEnabled = true
}


LeftGroupBox:AddToggle('Enabled', {
    Text = 'Target Lock',
    Default = getgenv().Francium.Enabled,
    Callback = function(Value)
        getgenv().Francium.Enabled = Value
    end
})

LeftGroupBox:AddToggle('Enabled', {
    Text = 'Tracer',
    Default = getgenv().Francium.TracerEnabled,
    Callback = function(Value)
        getgenv().Francium.TracerEnabled = Value
    end
})

LeftGroupBox:AddToggle('NoGroundShot', {
    Text = 'No Ground Shot',
    Default = getgenv().Francium.NoGroundShot,
    Callback = function(Value)
        getgenv().Francium.NoGroundShot = Value
    end
})

LeftGroupBox:AddToggle('LookAt', {
    Text = 'Look At',
    Default = getgenv().Francium.LookAt,
    Callback = function(Value)
        getgenv().Francium.LookAt = Value
    end
})

LeftGroupBox:AddToggle('resolvert', {
    Text = 'Resolver',
    Default = false,
    Callback = function(Value)
        getgenv().Francium.ResolverEnabled = Value
    end
})

LeftGroupBox:AddToggle('Triggerbot', {
    Text = 'Triggerbot',
    Default = getgenv().TRIGGERBOT_ENABLED,
    Callback = function(Value)
        getgenv().TRIGGERBOT_ENABLED = Value
    end
})

--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

--// Variables
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

getgenv().TRIGGERBOT_ENABLED = false

--// Startup Effect
local function startupEffect()
    local screenGui = Instance.new("ScreenGui")
    screenGui.IgnoreGuiInset = true
    screenGui.Parent = game.CoreGui

    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(0.5, 0, 0.2, 0)
    textLabel.Position = UDim2.new(0.25, 0, 0.4, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = "Konan"
    textLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
    textLabel.TextStrokeTransparency = 0
    textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    textLabel.Font = Enum.Font.GothamBlack
    textLabel.TextScaled = true
    textLabel.Parent = screenGui

    local tweenInfo = TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local textTweenOut = TweenService:Create(textLabel, tweenInfo, { TextTransparency = 1, TextStrokeTransparency = 1 })

    textLabel:TweenSize(UDim2.new(0.6, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 2, true)
    task.wait(2)

    textTweenOut:Play()
    task.wait(3)

    screenGui:Destroy()
end

--// Enemy Check
local function isEnemy(player)
    return player and player ~= LocalPlayer
end

--// Wall Check
local function isWallBetween(startPos, endPos)
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.IgnoreWater = true
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}

    local result = Workspace:Raycast(startPos, (endPos - startPos).Unit * (endPos - startPos).Magnitude, rayParams)
    return result and result.Instance and not result.Instance:IsDescendantOf(Players:GetPlayerFromCharacter(result.Instance.Parent))
end

--// Target Detection
local function getTarget()
    local origin = Camera.CFrame.Position
    local direction = Camera.CFrame.LookVector * 1000
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.IgnoreWater = true
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}

    local result = Workspace:Raycast(origin, direction, rayParams)

    if result and result.Instance then
        local character = result.Instance.Parent
        local player = Players:GetPlayerFromCharacter(character)
        local distance = (origin - result.Position).Magnitude

        if isEnemy(player) and not isWallBetween(origin, result.Position) then
            return player, distance
        end
    end
    return nil, nil
end

--// Tap Simulation
local function simulateTap(distance)
    local screenSize = Camera.ViewportSize
    local tapX, tapY = screenSize.X / 2, screenSize.Y / 2

    local delay = math.clamp(distance / 1000, 0.002, 0.01)

    VirtualInputManager:SendMouseButtonEvent(tapX, tapY, 0, true, game, 0)
    task.wait(delay)
    VirtualInputManager:SendMouseButtonEvent(tapX, tapY, 0, false, game, 0)
end

--// Triggerbot Loop
RunService.RenderStepped:Connect(function()
    if getgenv().TRIGGERBOT_ENABLED then
        local target, distance = getTarget()
        if target then
            print("Konan TRIGGERBOT ACTIVATED!")
            simulateTap(distance)
        end
    end
end)

--// Show intro
startupEffect()

local DickHead = Tabs.Main:AddLeftGroupbox('Camera')


DickHead:AddToggle('CamLock', {
    Text = 'Enable CamLock',
    Default = getgenv().Francium.Camera,
    Callback = function(Value)
        getgenv().Francium.Camera = Value
    end
})



DickHead:AddInput('Smoothness', {
    Default = tostring(getgenv().Francium.smoothness),
    Numeric = true,
    Text = 'Camera Smoothness',
    Callback = function(Value)
        getgenv().Francium.smoothness = tonumber(Value)
    end
})


local sigmaox = Tabs.Main:AddLeftGroupbox('Auto Air')



sigmaox:AddToggle('Flicker', {
    Text = 'Flick',
    Default = getgenv().Francium.Flick,
    Callback = function(Value)
        getgenv().Francium.Flick = Value
    end
})

sigmaox:AddToggle('Auto Air', {
    Text = 'Enable Auto Air',
    Default = getgenv().Francium.AutoAir,
    Callback = function(Value)
        getgenv().Francium.AutoAir = Value
    end
})

sigmaox:AddInput('ShootDelay', {
    Default = tostring(getgenv().Francium.ShootDelay),
    Numeric = true,
    Text = 'Shoot Delay',
    Callback = function(Value)
        getgenv().Francium.ShootDelay = tonumber(Value)
    end
})




local RightGroupBox = Tabs.Main:AddRightGroupbox('Prediction Settings')

RightGroupBox:AddInput('HorizontalPrediction', {
    Default = tostring(getgenv().Francium.HorizontalPrediction),
    Numeric = true,
    Text = 'Horizontal Prediction',
    Callback = function(Value)
        if not getgenv().Francium.AutoPrediction then
            getgenv().Francium.HorizontalPrediction = tonumber(Value)
        end
    end
})

RightGroupBox:AddInput('VerticalPrediction', {
    Default = tostring(getgenv().Francium.VerticalPrediction),
    Numeric = true,
    Text = 'Vertical Prediction',
    Callback = function(Value)
        if not getgenv().Francium.AutoPrediction then
            getgenv().Francium.VerticalPrediction = tonumber(Value)
        end
    end
})

RightGroupBox:AddInput('Jump Offset', {
    Default = tostring(getgenv().Francium.jumpoffset),
    Text = 'Jump Offset',
    Callback = function(Value)
        getgenv().Francium.jumpoffset = Value
    end
})

RightGroupBox:AddToggle('AutoPrediction', {
    Text = 'Auto Prediction',
    Default = getgenv().Francium.AutoPrediction,
    Callback = function(Value)
        getgenv().Francium.AutoPrediction = Value
    end
})



-- Dropdown for Auto Prediction Mode
RightGroupBox:AddDropdown('AutoPredMode', {
    Values = { 'AdvanceCalculation', 'PingBased', 'Calculation', 'Blatant' },
    Default = getgenv().Francium.AutoPredMode == 'PingBased' and 2 or 1, -- Default to PingBased
    Text = 'Auto Prediction Mode',
    Callback = function(Value)
        getgenv().Francium.AutoPredMode = Value
    end
})

RightGroupBox:AddDropdown('SelectedPart', {
    Values = { 'Head', 'LowerTorso', 'UpperTorso', 'HumanoidRootPart' },
    Default = getgenv().Francium.SelectedPart == 'Head' and 1 or
              getgenv().Francium.SelectedPart == 'LowerTorso' and 2 or
              getgenv().Francium.SelectedPart == 'UpperTorso' and 3 or 4,
    Text = 'Target Part',
    Callback = function(Value)
        getgenv().Francium.SelectedPart = Value
    end
})

local RightGroupBox99 = Tabs.Main:AddRightGroupbox('Silent Aim')

RightGroupBox99:AddToggle('Si9282829382991lent', {
    Text = 'Silent Aim',
    Default = getgenv().Francium.SilentAim,
    Callback = function(Value)
        getgenv().Francium.SilentAim = Value
    end
})

RightGroupBox99:AddToggle('Silen3838322222182891929t', {
    Text = 'Fov',
    Default = false,
    Callback = function(Value)
        getgenv().ShowFOV = Value
    end
})


RightGroupBox99:AddInput('Fov Si9182819ze', {
    Default = tostring(getgenv().FOVSize or 25),
    Numeric = true,
    Text = 'Fov Size',
    Callback = function(Value)
        getgenv().FOVSize = tonumber(Value)
    end
})

local RightGroupBox2 = Tabs.Main:AddRightGroupbox('Anti Lock')

RightGroupBox2:AddToggle('AntiEnabled', {
    Text = 'Enable Anti',
    Default = getgenv().Francium.AntiEnabled,
    Callback = function(Value)
        getgenv().Francium.AntiEnabled = Value
    end
})


RightGroupBox2:AddDropdown('SelectedMode', {
    Values = { 'Predbreaker', 'Sky', 'Ground' },
    Default = getgenv().Francium.AntiLock == 'Predbreaker' and 1 or
              getgenv().Francium.AntiLock == 'Sky' and 2 or 3,
    Text = 'Mode Selection',
    Callback = function(Value)
        getgenv().Francium.AntiLock = Value
    end
})


local LeftGp = Tabs.Misc:AddLeftGroupbox('Cframe')

getgenv().speedvalue = 0.9

LeftGp:AddInput('Spe992ed', {
    Default =  tostring(getgenv().speedvalue),
    Numeric = true,
    Text = 'Speed',
    Callback = function(Value)
        getgenv().speedvalue = tonumber(Value)
    end
})


LeftGp:AddToggle('Cfra992me', {
    Text = 'Cframe',
    Default = false,
    Callback = function(Value)
        getgenv().cframespeedtoggle = Value
    end
})

-- Adding Macro Button under Misc Tab
local MacroGroup = Tabs.Misc:AddLeftGroupbox('Macro Settings')

MacroGroup:AddButton('Macro', function()
    if getgenv().Konan.Macro == "OFF" then
        getgenv().Konan.Macro = "ON"
        getgenv().Speed = 0.01 -- Lower value = faster macro speed
        loadstring(game:HttpGet("https://raw.githubusercontent.com/CookieScript/Trace.Iol/refs/heads/main/Macro", true))()
        Library:Notify('Macro Enabled')
    else
        getgenv().Francium.Macro = "OFF"
        Library:Notify('Macro Disabled')
    end
end)

local InvisGroup = Tabs.Misc:AddLeftGroupbox('Invis')  

InvisGroup:AddButton('Invis', function()
loadstring(game:HttpGet('https://pastebin.com/raw/3Rnd9rHf'))()
end)

-- Add Auto Armor toggle button in Misc tab
local AutoArmorGroup = Tabs.Misc:AddRightGroupbox('Auto Stuff')

AutoArmorGroup:AddToggle('AutoArmor', { 
    Text = 'Enable Auto Armor',
    Default = false,
    Callback = function(Value)
        getgenv().AutoArmor = Value
    end
})

-- Function to check if armor is already equipped
local function IsArmorEquipped()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if character then
        for _, item in pairs(character:GetChildren()) do
            if item:IsA("Tool") and item.Name:match("Armor") then
                return true  -- Armor is equipped
            end
        end
    end
    return false  -- No armor found
end

-- Function to buy armor when it's gone
local function BuyArmor()
    local armorPad = workspace:FindFirstChild("MAP") and workspace.MAP.Pads:FindFirstChild("[Medium Armor]")
    if armorPad and armorPad:FindFirstChild("ClickDetector") then
        fireclickdetector(armorPad.ClickDetector)
    end
end

-- Function to equip armor from backpack
local function EquipArmor()
    local player = game.Players.LocalPlayer
    local character = player.Character
    local backpack = player.Backpack

    if character and backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") and item.Name:match("Armor") then
                item.Parent = character  -- Equip the armor
                return
            end
        end
    end
end

-- Auto Armor Logic (Only Rebuys When Armor is Gone)
game:GetService("RunService").Heartbeat:Connect(function()
    if getgenv().AutoArmor then
        if not IsArmorEquipped() then  -- Only buy armor if it's missing
            BuyArmor()
            wait(1.1)  -- Wait for armor to appear in the backpack
            EquipArmor()
        end
    end
end)

AutoArmorGroup:AddToggle("AutoPizza", {
    Text = 'Enable Auto Pizza', 
    Title = "Enable Auto Pizza",
    Default = false,
    Callback = function(v)
        autoPizzaEnabled = v
        if autoPizzaEnabled then
            pizzaThread = task.spawn(function()
                while autoPizzaEnabled and task.wait() do
                    local pizzaPad = workspace:FindFirstChild("MAP") and workspace.MAP:FindFirstChild("Pads") and workspace.MAP.Pads:FindFirstChild("[Pizza]")
                    if pizzaPad and pizzaPad:FindFirstChild("ClickDetector") then
                        fireclickdetector(pizzaPad.ClickDetector)
                    end
                end
            end)
        else
            if pizzaThread then
                task.cancel(pizzaThread)
            end
        end
    end
})

local Visuals = 
Tabs.Misc:AddRightGroupbox('Visuals')

Visuals:AddToggle("EnableESP", {
    Text = "Enable ESP",
    Default = getgenv().ESPEnabled,
}):OnChanged(function(state)
    getgenv().ESPEnabled = state
end)


-- Dropdown list for Crosshair Toggle
local CrosshairEnabled = false

Visuals:AddToggle(
    "Crosshair",
    {
        Text = "Crosshair",
        Default = false,
        Tooltip = "Enable or disable Crosshair",
        Callback = function(state)
            CrosshairEnabled = state
        end
    }
)

-- Crosshair settings
getgenv().crosshair = {
    enabled = true,
    refreshrate = 0.015,
    mode = 'center',
    position = Vector2.new(0, 0),
    width = 2.5,
    length = 10,
    radius = 11,
    color = Color3.fromRGB(86, 87, 142),  -- Color for the crosshair lines
    spin = true,
    spin_speed = 150,
    spin_max = 340,
    spin_style = Enum.EasingStyle.Circular,
    resize = true,
    resize_speed = 150,
    resize_min = 5,
    resize_max = 22,
}

local old; old = hookfunction(Drawing.new, function(class, properties)
    local drawing = old(class)
    for i, v in next, properties or {} do
        drawing[i] = v
    end
    return drawing
end)

local runservice = game:GetService('RunService')
local inputservice = game:GetService('UserInputService')
local tweenservice = game:GetService('TweenService')
local camera = workspace.CurrentCamera

local last_render = 0

local drawings = {
    crosshair = {},
    text = {
        Drawing.new('Text', {Size = 13, Font = 2, Outline = true, Text = 'Konan', Color = Color3.new(255, 255, 255)}),
        Drawing.new('Text', {Size = 13, Font = 2, Outline = true, Text = '.CC', Color = Color3.fromRGB(86, 87, 142)}),
    }
}

for idx = 1, 4 do
    drawings.crosshair[idx] = Drawing.new('Line')
    drawings.crosshair[idx + 4] = Drawing.new('Line')
end

function solve(angle, radius)
    return Vector2.new(
        math.sin(math.rad(angle)) * radius,
        math.cos(math.rad(angle)) * radius
    )
end

runservice.PostSimulation:Connect(function()
    local _tick = tick()

    if _tick - last_render > crosshair.refreshrate then
        last_render = _tick

        local position = camera.ViewportSize / 2

        local text_1 = drawings.text[1]
        local text_2 = drawings.text[2]

        text_1.Visible = CrosshairEnabled
        text_2.Visible = CrosshairEnabled

        if CrosshairEnabled then
            local text_x = text_1.TextBounds.X + text_2.TextBounds.X

            text_1.Position = position + Vector2.new(-text_x / 2, crosshair.radius + (crosshair.resize and crosshair.resize_max or crosshair.length) + 5)
            text_2.Position = text_1.Position + Vector2.new(text_1.TextBounds.X, 0)
            text_2.Color = Color3.fromRGB(86, 87, 142)

            for idx = 1, 4 do
                local outline = drawings.crosshair[idx]
                local inline = drawings.crosshair[idx + 4]

                local angle = (idx - 1) * 90
                local length = crosshair.length

                if crosshair.spin then
                    local spin_angle = -_tick * crosshair.spin_speed % crosshair.spin_max
                    angle = angle + tweenservice:GetValue(spin_angle / 360, crosshair.spin_style, Enum.EasingDirection.InOut) * 360
                end

                if crosshair.resize then
                    local resize_length = tick() * crosshair.resize_speed % 180
                    length = crosshair.resize_min + math.sin(math.rad(resize_length)) * crosshair.resize_max
                end

                inline.Visible = true
                inline.Color = Color3.fromRGB(86, 87, 142)  -- Set color for all inline lines
                inline.From = position + solve(angle, crosshair.radius)
                inline.To = position + solve(angle, crosshair.radius + length)
                inline.Thickness = crosshair.width

                outline.Visible = true
                outline.From = position + solve(angle, crosshair.radius - 1)
                outline.To = position + solve(angle, crosshair.radius + length + 1)
                outline.Thickness = crosshair.width + 1.5    
            end
        else
            for idx = 1, 4 do
                drawings.crosshair[idx].Visible = false
                drawings.crosshair[idx + 4].Visible = false
            end
        end
    end
end)

local effectEnabled = false -- Variable to control the toggle state
local forceFieldColor = Color3.fromRGB(128, 0, 128) -- Default force field color (purple)

-- Toggle Button for Effect
Visuals:AddToggle(
    "Visuals",
    {
        Text = "Force Field", -- 
        Default = false,
        Tooltip = "Enable or disable the effect on MeshParts ",
        Callback = function(state)
            effectEnabled = state
        end
    }
)

-- Color Picker for Force Field Color
Toggles.Visuals:AddColorPicker(
    "Color",
    {
        Default = Color3.fromRGB(128, 0, 128), -- Default purple color
        Title = "Force Field Color", -- Tooltip for the picker
        Callback = function(color)
            forceFieldColor = color -- Update the color variable dynamically
        end
    }
)

-- Apply effect if enabled
spawn(function()
    while wait() do
        for _, part in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
            if part:IsA("MeshPart") then
                if effectEnabled then
                    part.Material = Enum.Material.ForceField
                    part.Color = forceFieldColor -- Use the dynamically updated color
                else
                    -- Revert to original properties
                    part.Material = Enum.Material.SmoothPlastic -- Change this to the original material you want
                    part.Color = Color3.fromRGB(255, 255, 255) -- Change this to the original color you want (white)
                end
            end
        end
    end
end)

--// SPINBOT SETUP
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local SpinEnabled = false
local SpinSpeed = 15

--// SPINBOT LOOP
RunService.RenderStepped:Connect(function()
    if SpinEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        root.CFrame = root.CFrame * CFrame.Angles(0, math.rad(SpinSpeed), 0)
    end
end)

--// UI ELEMENTS
Visuals:AddToggle("SpinbotToggle", {
    Text = "Enable Spinbot",
    Default = false,
    Tooltip = "Toggle character spin",
}):OnChanged(function(value)
    SpinEnabled = value
end)

Visuals:AddSlider("SpinSpeedSlider", {
    Text = "Spin Speed",
    Default = 15,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Compact = false,
}):OnChanged(function(value)
    SpinSpeed = value
end)

-- UI Settings tab (kept as-is)
local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu")

MenuGroup:AddToggle("ShowCustomCursor", {
    Text = "Custom Cursor",
    Default = true,
    Callback = function(Value)
        Library.ShowCustomCursor = Value
    end,
})

MenuGroup:AddLabel("Menu bind")
    :AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Menu keybind" })

MenuGroup:AddButton("Unload", function()
    Library:Unload()
end)

Library.ToggleKeybind = Options.MenuKeybind

-- Setup Theme & Save Managers
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

ThemeManager:SetFolder("KonanUi")
SaveManager:SetFolder("Konan.cc/spec")
SaveManager:SetSubFolder("spec")

SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])
SaveManager:LoadAutoloadConfig()


game:GetService("RunService").Heartbeat:Connect(function()
    local player = game.Players.LocalPlayer
    local character = player.Character

    if character and character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = character.HumanoidRootPart
        local vel = humanoidRootPart.Velocity

        if getgenv().cframespeedtoggle == true then
            humanoidRootPart.CFrame = humanoidRootPart.CFrame +
                character.Humanoid.MoveDirection * getgenv().speedvalue / 0.5
        end

        if getgenv().Francium.AntiEnabled then
            if getgenv().Francium.AntiLock == "Predbreaker" then
                humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            elseif getgenv().Francium.AntiLock == "Sky" then
                humanoidRootPart.Velocity = Vector3.new(0, 100, 0)
            elseif getgenv().Francium.AntiLock == "Ground" then
                humanoidRootPart.Velocity = Vector3.new(0, -400, 0)
            end
        end

        game:GetService("RunService").RenderStepped:Wait()
        humanoidRootPart.Velocity = vel
    end
end)


local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local CoreGui = game:GetService("CoreGui")
local dragging, dragInput, dragStart, startPos



local function createScreenGui()
    local existingGui = CoreGui:FindFirstChild("MyScreenGui")
    if existingGui then
        return existingGui
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MyScreenGui"
    screenGui.Parent = CoreGui
    return screenGui
end

local function initializeToggleButton(screenGui)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 1, 0, 1)
    button.Position = UDim2.new(1, -100, 0, 80)
    button.Text = "."
    button.Font = Enum.Font.Arcade 
    button.TextSize = 1
    button.BackgroundColor3 = Color3.new(0, 0, 0)
    button.BackgroundTransparency = 1
    button.TextColor3 = Color3.new(1, 1, 1)
    button.BorderSizePixel = 0

    button.ClipsDescendants = true
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 5)
    corner.Parent = button

    button.Parent = screenGui

    button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            -- Trigger the toggle function on each click
            Library:Toggle()

            dragging = true
            dragStart = input.Position
            startPos = button.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    button.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
            dragInput = input
            local delta = dragInput.Position - dragStart
            button.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

local screenGui = createScreenGui()
initializeToggleButton(screenGui)


getgenv().Francium.LockType = "Namecall"
getgenv().Francium.RESOLVER = "MoveDirection"



local game_support = 
loadstring(game:HttpGet("https://raw.githubusercontent.com/LuarmorIsGay5/automatic-spork/refs/heads/main/Argument.txt",true))() 




    local Sigmaballs = Instance.new("ScreenGui")
    Sigmaballs.Name = "Sigmaballs"
    Sigmaballs.Parent = game.CoreGui
    Sigmaballs.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    Sigmaballs.ResetOnSpawn = false

    local ImageButton = Instance.new("ImageButton")
    ImageButton.Name = "ImageButton"
    ImageButton.Parent = Sigmaballs
    ImageButton.Active = true
    ImageButton.Draggable = true
    ImageButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    ImageButton.BackgroundTransparency = 0.350
    ImageButton.Size = UDim2.new(0, 90, 0, 90)
    ImageButton.Image = "rbxassetid://112662832844294"
    ImageButton.Position = UDim2.new(0.5, -25, 0.5, -25)

    local Ui2corner = Instance.new("UICorner")
    Ui2corner.CornerRadius = UDim.new(0.2, 0)
    Ui2corner.Parent = ImageButton


local player = game.Players.LocalPlayer
local Plr = nil
local enabled = false


local FOV43 = Drawing.new("Circle")
FOV43.Transparency = 0.5
FOV43.Thickness = 2
FOV43.Color = Color3.new(1, 0, 0)
FOV43.Filled = false
FOV43.Radius = 250
FOV43.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
FOV43.Visible = false

function SigmaOhioPlayer()
    local mouse = player:GetMouse()
    local closestPlayer
    local shortestDistance = math.huge
    local CC = game:GetService("Workspace").CurrentCamera
    local screenCenter = Vector2.new(CC.ViewportSize.X / 2, CC.ViewportSize.Y / 2)
    local fovRadius = FOV43.Radius
    local viewportSize = CC.ViewportSize

    for i, v in pairs(game.Players:GetPlayers()) do
        if v ~= player and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("HumanoidRootPart") then
            local pos, onScreen = CC:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            
            if onScreen and pos.X > 0 and pos.Y > 0 and pos.X < viewportSize.X and pos.Y < viewportSize.Y then
                local magnitude = (Vector2.new(pos.X, pos.Y) - screenCenter).magnitude
                if magnitude < fovRadius and magnitude < shortestDistance then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end

function createTracer(localPlayer, targetPlayer)
    if localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and
       targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then

        local tracerAttachment1 = Instance.new("Attachment", localPlayer.Character.HumanoidRootPart)
        local tracerAttachment2 = Instance.new("Attachment", targetPlayer.Character.HumanoidRootPart)

        local tracerBeam = Instance.new("Beam")
        tracerBeam.Attachment0 = tracerAttachment1
        tracerBeam.Attachment1 = tracerAttachment2
        tracerBeam.Color = ColorSequence.new(Color3.fromRGB(153, 0, 153))
        tracerBeam.Width0 = 0.080
        tracerBeam.Width1 = 0.080
        tracerBeam.Parent = localPlayer.Character.HumanoidRootPart

        tracernigger = tracerBeam  

        targetPlayer.CharacterAdded:Connect(function(newCharacter)
            if tracernigger then
                tracernigger:Destroy()  
                tracernigger = nil
            end

            newCharacter:WaitForChild("HumanoidRootPart")
            tracerAttachment2.Parent = newCharacter.HumanoidRootPart
            tracernigger = tracerBeam  
        end)
    end
end

function destroyTracer()
    if tracernigger then
        tracernigger:Destroy()
        tracernigger = nil
    end
end




function LookAtPlayer(Target)
    local localChar = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local localHumanoidRootPart = localChar:FindFirstChild("HumanoidRootPart")

    if localHumanoidRootPart then
        if getgenv().Francium and getgenv().Francium.LookAt then
            if Target and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart") then
                local targetHumanoidRootPart = Target.Character.HumanoidRootPart
                
                local targetPosition = targetHumanoidRootPart.Position
                local localPosition = localHumanoidRootPart.Position
                
                local horizontalDirection = Vector3.new(targetPosition.X - localPosition.X, 0, targetPosition.Z - localPosition.Z).unit
                
                localHumanoidRootPart.CFrame = CFrame.new(localPosition, localPosition + horizontalDirection)
                localChar.Humanoid.AutoRotate = false
            end
        else
            localChar.Humanoid.AutoRotate = true
        end
    end
    
    if not (Target and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart")) then
        localChar.Humanoid.AutoRotate = true
    end
end

local function toggleLock()
    if enabled then
        ImageButton.Image = "rbxassetid://112662832844294"
        enabled = false
        Plr = nil
        destroyTracer()  

        Library:Notify('Lock Off')
    else
        Plr = SigmaOhioPlayer()
        if Plr then
            enabled = true
            if getgenv().Francium.TracerEnabled then
            createTracer(game.Players.LocalPlayer, Plr)  
        end
            
            ImageButton.Image = "rbxassetid://110547437790278"
Library:Notify("Abusing Locked On: " .. tostring(Plr.Character.Humanoid.DisplayName)
            
            )
        end
    end
end

-- // GUI Toggle
ImageButton.MouseButton1Click:Connect(toggleLock)

-- // Controller Support - Y Button
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.ButtonY then
        toggleLock()
    end
end)

local function getRemoteInfo()
    local placeId = game.PlaceId
    return game_support[placeId] or { Remote = "MainEvent", Argument = "UpdateMousePos" }
end

local remoteInfo = getRemoteInfo()
local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)

local Vect3 = Vector3.new


local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(...)
    local args = {...}
    local method = getnamecallmethod()

    if getgenv().Francium.Enabled and getgenv().Francium.LockType == "Namecall" then
        if Plr and Plr.Character and method == "FireServer" and (args[2] == remoteInfo.Argument) then
            local selectedPart = getgenv().Francium.SelectedPart
            local targetPart = Plr.Character[selectedPart]

            if targetPart then
                local velocity
                if getgenv().Francium.ResolverEnabled then
                    if getgenv().Francium.RESOLVER == "MoveDirection" then
                        velocity = Plr.Character.Humanoid.MoveDirection * Plr.Character.Humanoid.WalkSpeed
                    elseif getgenv().Francium.RESOLVER == "LookVector" then
                        velocity = targetPart.CFrame.LookVector * getgenv().Francium.HorizontalPrediction * 1.0
                    else
                        velocity = targetPart.Velocity
                    end
                else
                    velocity = targetPart.Velocity
                end

                local horizontalPrediction = getgenv().Francium.HorizontalPrediction
                local verticalPrediction = getgenv().Francium.VerticalPrediction
                local jumpOffset = getgenv().Francium.jumpoffset or 0

                if not getgenv().Francium.ResolverEnabled then
                    args[3] = Vector3.new(
                        targetPart.Position.X + (velocity.X * horizontalPrediction),
                        targetPart.Position.Y + (velocity.Y * verticalPrediction) + jumpOffset,
                        targetPart.Position.Z + (velocity.Z * horizontalPrediction)
                    )
                else
                    args[3] = targetPart.Position + (velocity or Vector3.new()) * horizontalPrediction + Vector3.new(0, jumpOffset, 0)
                end

                return old(unpack(args))
            end
        end
    end

    return old(...)
end)

setreadonly(mt, true)

local Stas = game:GetService("Stats")

local RunService = game:GetService("RunService")


local Blatant = {
    {50, 0.12758545757236864},
    {60, 0.12593338424986178},
    {70, 0.1416310605747206},
    {80, 0.1441481061236737},
    {90, 0.14306050263254388},
    {100, 0.14698413210558095},
    {110, 0.14528324362031425},
    {120, 0.14556534594403},
    {130, 0.14614337395777216},
    {140, 0.14645603036905414},
    {150, 0.14736848095666674},
    {160, 0.14696985547996216},
    {170, 0.14718530231216217},
    {180, 0.1471532933015037},
    {190, 0.1471212842908452},
    {200, 0.14708927528018672},
    {210, 0.14705726626952823},
    {220, 0.14702525725886974},
    {230, 0.14699324824821125},
    {240, 0.14696123923755276},
    {250, 0.14692923022689427},
    {260, 0.14689722121623578},
    {270, 0.1468652122055773},
    {280, 0.1468332031949188},
    {290, 0.1468011941842603},
    {300, 0.1467691851736018},
}

local predictionTable = {
    {0, 0.1332},
    {10, 0.1234555},
    {20, 0.12435},
    {30, 0.124123},
    {40, 0.12766},
    {50, 0.128643},
    {60, 0.1264236},
    {70, 0.12533},
    {80, 0.1321042},
    {90, 0.1421951},
    {100, 0.134143},
    {105, 0.141199},
    {110, 0.142199},
    {125, 0.15465},
    {130, 0.12399},
    {135, 0.1659921},
    {140, 0.1659921},
    {145, 0.129934},
    {150, 0.1652131},
    {155, 0.125333},
    {160, 0.1223333},
    {165, 0.1652131},
    {170, 0.16863},
    {175, 0.16312},
    {180, 0.1632},
    {185, 0.16823},
    {190, 0.18659},
    {205, 0.17782},
    {215, 0.16937},
    {225, 0.176332},
}

local function calculateAdvancePrediction(target, cameraPosition, pingBase)
    local character = Plr.Character and Plr.Character.Parent
    if character then
        local GoodPartTheCom = character:FindFirstChild("HumanoidRootPart")
        if GoodPartTheCom then
            local Velop = GoodPartTheCom.Velocity
            local distanc11 = (cameraPosition - GoodPartTheCom.Position).Magnitude
            local advancePrediction = pingBase + (distanc11 / 1000) * (Velop.Magnitude / 50)
            return advancePrediction
        end
    end
    return pingBase
end

local function updatePredictionValue()
    if getgenv().Francium.AutoPrediction then
        local pingValue = Stas.Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingValue, '(')
        local ping = tonumber(split[1])

        if ping then
            if getgenv().Francium.AutoPredMode == "PingBased" then
                for i = 1, #predictionTable do
                    if ping < predictionTable[i][1] then
                        local value = predictionTable[i][2]
                        getgenv().Francium.HorizontalPrediction = value
                        getgenv().Francium.VerticalPrediction = value
                        break
                    end
                end
            elseif getgenv().Francium.AutoPredMode == "Calculation" then
                local calculatedValue = 0.1 + (ping / 1000) * 0.32
                getgenv().Francium.HorizontalPrediction = calculatedValue
                getgenv().Francium.VerticalPrediction = calculatedValue
            elseif getgenv().Francium.AutoPredMode == "AdvanceCalculation" then
                for i = 1, #predictionTable do
                    if ping < predictionTable[i][1] then
                        local pingBase = predictionTable[i][2]
                        local advancePredictionValue = calculateAdvancePrediction(Plr, workspace.CurrentCamera.CFrame.Position, pingBase)
                        getgenv().Francium.HorizontalPrediction = advancePredictionValue
                        getgenv().Francium.VerticalPrediction = advancePredictionValue
                        break
                    end
                end
            elseif getgenv().Francium.AutoPredMode == "Blatant" then
                for i = 1, #Blatant do
                    if ping < Blatant[i][1] then
                        local value = Blatant[i][2]
                        getgenv().Francium.HorizontalPrediction = value
                        getgenv().Francium.VerticalPrediction = value
                        break
                    end
                end
            end
        end
    end
end


RunService.Heartbeat:Connect(function()
    if getgenv().Francium.Flick and Plr and Plr.Character then
        local playerHumanoid = Plr.Character:FindFirstChild("Humanoid")
        if playerHumanoid and playerHumanoid.Health > 0 then
       
            local targetPart = Plr.Character:FindFirstChild("UpperTorso") or Plr.Character:FindFirstChild("Head")
            if targetPart and playerHumanoid.FloorMaterial == Enum.Material.Air then
                local camera = workspace.CurrentCamera
                local targetPosition = targetPart.Position + targetPart.Velocity * getgenv().Francium.VerticalPrediction
                camera.CFrame = CFrame.new(camera.CFrame.Position, targetPosition)
            end
        end
    end
end)



RunService.Heartbeat:Connect(function()
    if getgenv().Francium.Camera and Plr and Plr.Character and getgenv().Francium.SelectedPart then
        local camera = Workspace.CurrentCamera
        local selectedPart = getgenv().Francium.SelectedPart
        local targetPart = Plr.Character[selectedPart]

        if targetPart then
            local velocity
            if getgenv().Francium.ResolverEnabled then
                if getgenv().Francium.RESOLVER == "MoveDirection" then
                    velocity = Plr.Character.Humanoid.MoveDirection * Plr.Character.Humanoid.WalkSpeed
                elseif getgenv().Francium.RESOLVER == "LookVector" then
                    velocity = targetPart.CFrame.LookVector * getgenv().Francium.HorizontalPrediction * 1.0
                else
                    velocity = targetPart.Velocity
                end
            else
                velocity = targetPart.Velocity
            end

            local jumpOffset = getgenv().Francium.jumpoffset or 0
            local fallOffset = getgenv().Francium.FallOffset or 0

            local verticalVelocity = velocity.Y
            local appliedVerticalOffset = 0

            if verticalVelocity > 0 then
                appliedVerticalOffset = jumpOffset
            elseif verticalVelocity < 0 then
                appliedVerticalOffset = -fallOffset
            end

            local horizontalPrediction = getgenv().Francium.HorizontalPrediction
            local verticalPrediction = getgenv().Francium.VerticalPrediction

            local targetPosition = Vector3.new(
                targetPart.Position.X + (velocity.X * horizontalPrediction),
                targetPart.Position.Y + (velocity.Y * verticalPrediction) + appliedVerticalOffset,
                targetPart.Position.Z + (velocity.Z * horizontalPrediction)
            )

            local smoothness = getgenv().Francium.smoothness or 0.1 
            camera.CFrame = camera.CFrame:Lerp(CFrame.new(camera.CFrame.Position, targetPosition), smoothness)
        end
    end
end)

local players = game:GetService("Players")
local client = players.LocalPlayer

local function AutoShoot()
    if Plr then
        local character = client.Character
        if character then
            local tool = character:FindFirstChildOfClass("Tool")
            if tool and tool:IsA("Tool") then
                tool:Activate()
            end
        else
            warn("Character not found for client")
        end
    else
        warn("No target (Plr) found")
    end
end

local Shot2ing = false

local function ApplyAntiGround()
    local character = Plr.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if humanoidRootPart then
        local velocity = humanoidRootPart.Velocity
        local SigmaAir = humanoidRootPart.Position.Y > 2

        if not SigmaAir and velocity.Y < -3 then
            if getgenv().Francium.NoGroundShot then
                humanoidRootPart.Velocity = Vector3.new(velocity.X, 0, velocity.Z)
            end
        else
            if not getgenv().Francium.NoGroundShot then
                humanoidRootPart.Velocity = Vector3.new(velocity.X, velocity.Y, velocity.Z)
            end
        end
    end
end

local targetSigm99928 = getgenv().Francium.ShootDelay 
local targetSigmaPOBALLs = nil

local function checkTarget()
    if Plr and Plr.Character then
        local humanoid = Plr.Character:FindFirstChildOfClass("Humanoid")
        local humanoidRootPart = Plr.Character:FindFirstChild("HumanoidRootPart")
        
        if humanoid and humanoidRootPart then
            local SigmaAir = humanoid:GetState() == Enum.HumanoidStateType.Freefall or humanoidRootPart.Velocity.Y > 2
            
         
            if SigmaAir and getgenv().Francium.AutoAir then
                if not targetSigmaPOBALLs then
                    
                    targetSigmaPOBALLs = tick()
                else
                   
                    local airDuration = tick() - targetSigmaPOBALLs
                    if airDuration >= targetSigm99928 then
                        if not Shot2ing then
                            Shot2ing = true
                            while Plr and Plr.Character and (SigmaAir) do
                                AutoShoot()
                                wait(0.001)
                               
                                SigmaAir = humanoid:GetState() == Enum.HumanoidStateType.Freefall or humanoidRootPart.Velocity.Y > 2
                                
                                
                                if not SigmaAir then
                                    Shot2ing = false
                                    targetSigmaPOBALLs = nil -- Reset the start time
                                    break
                                end
                            end
                            Shot2ing = false
                        end
                    end
                end
            else
                
                targetSigmaPOBALLs = nil
                Shot2ing = false
            end
        end
    end
end





game:GetService("RunService").RenderStepped:Connect(function()
    LookAtPlayer(Plr)
    checkTarget()
    if Plr then
        updatePredictionValue()
        ApplyAntiGround()
    end
end)


local Camera = workspace.CurrentCamera



getgenv().Filled = false
getgenv().FOVTransparency = 0.8
getgenv().FOVThickness = 1
getgenv().FOVColor = Color3.new(1, 1, 1)
getgenv().ShowFOV = false
getgenv().FOVSize = 25


local FOV = Drawing.new("Circle")
FOV.Transparency = getgenv().FOVTransparency
FOV.Thickness = getgenv().FOVThickness
FOV.Color = getgenv().FOVColor
FOV.Filled = getgenv().Filled
FOV.Radius = getgenv().FOVSize
FOV.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

local function IsPlayerInFOV(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end

    local characterRootPart = player.Character.HumanoidRootPart
    local screenPosition, onScreen = Camera:WorldToViewportPoint(characterRootPart.Position)
    local centerScreenPosition = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local distance = (centerScreenPosition - Vector2.new(screenPosition.X, screenPosition.Y)).Magnitude

    if onScreen and distance <= FOV.Radius then
        local ray = Ray.new(Camera.CFrame.Position, (characterRootPart.Position - Camera.CFrame.Position).unit * 500)
        local part, position = workspace:FindPartOnRay(ray, LocalPlayer.Character)
        return not part or part:IsDescendantOf(player.Character)
    end
    return false
end


RunService.RenderStepped:Connect(function()
    FOV.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    FOV.Radius = getgenv().FOVSize
    FOV.Visible = getgenv().ShowFOV
targetSigm99928 = getgenv().Francium.ShootDelay

    if getgenv().Francium.SilentAim then
        local NiggerLocated = false

        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and IsPlayerInFOV(player) then
                NiggerLocated = true
                Plr = player
                break
            end
        end

        if not NiggerLocated then
            Plr = nil
        end
    end
end) 

--// Universal Box ESP Toggleable with Linoria UI

-- ESP Settings
getgenv().ESPEnabled = true
local settings = {
    defaultcolor = Color3.fromRGB(255, 0, 0),
    teamcheck = false,
    teamcolor = true
}

-- Services
local runService = game:GetService("RunService")
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer
local camera = workspace.CurrentCamera

-- Drawing Utility
local newVector2, newColor3, newDrawing = Vector2.new, Color3.new, Drawing.new
local tan, rad = math.tan, math.rad
local round = function(...) local a = {}; for i,v in next, table.pack(...) do a[i] = math.round(v); end return unpack(a); end
local wtvp = function(...) local a, b = camera:WorldToViewportPoint(...) return newVector2(a.X, a.Y), b, a.Z end

-- ESP Logic
local espCache = {}

local function createEsp(player)
    if espCache[player] then return end

    local drawings = {}
    drawings.box = newDrawing("Square")
    drawings.box.Thickness = 1
    drawings.box.Filled = false
    drawings.box.Color = settings.defaultcolor
    drawings.box.Visible = false
    drawings.box.ZIndex = 2

    drawings.boxoutline = newDrawing("Square")
    drawings.boxoutline.Thickness = 3
    drawings.boxoutline.Filled = false
    drawings.boxoutline.Color = newColor3()
    drawings.boxoutline.Visible = false
    drawings.boxoutline.ZIndex = 1

    espCache[player] = drawings
end

local function removeEsp(player)
    if rawget(espCache, player) then
        for _, drawing in next, espCache[player] do
            drawing:Remove()
        end
        espCache[player] = nil
    end
end

local function updateEsp(player, esp)
    local character = player and player.Character
    if not character then
        esp.box.Visible = false
        esp.boxoutline.Visible = false
        return
    end

    local cframe = character:GetModelCFrame()
    local position, visible, depth = wtvp(cframe.Position)
    esp.box.Visible = visible and ESPEnabled
    esp.boxoutline.Visible = visible and ESPEnabled

    if cframe and visible then
        local scaleFactor = 1 / (depth * tan(rad(camera.FieldOfView / 2)) * 2) * 1000
        local width, height = round(4 * scaleFactor, 5 * scaleFactor)
        local x, y = round(position.X, position.Y)

        esp.box.Size = newVector2(width, height)
        esp.box.Position = newVector2(round(x - width / 2, y - height / 2))
        esp.box.Color = settings.teamcolor and player.TeamColor.Color or settings.defaultcolor

        esp.boxoutline.Size = esp.box.Size
        esp.boxoutline.Position = esp.box.Position
    end
end

-- Auto Track Players
for _, player in next, players:GetPlayers() do
    if player ~= localPlayer then
        createEsp(player)
    end
end

players.PlayerAdded:Connect(createEsp)
players.PlayerRemoving:Connect(removeEsp)

-- Render ESP
runService:BindToRenderStep("esp", Enum.RenderPriority.Camera.Value, function()
    for player, drawings in next, espCache do
        if settings.teamcheck and player.Team == localPlayer.Team then continue end
        if player ~= localPlayer then updateEsp(player, drawings) end
    end
end)
